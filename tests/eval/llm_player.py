#!/usr/bin/env python3
import json
import urllib.request
import urllib.error
import os
import sys
import argparse
import time

def parse_args():
    parser = argparse.ArgumentParser(description="LLM Player for Gomoku")
    parser.add_argument("--url", default="http://127.0.0.1:8080", help="URL of gomoku-httpd")
    parser.add_argument("--model", default="gpt-4", help="OpenAI model to use (if using LLM)")
    parser.add_argument("--manual", action="store_true", help="Manual mode (human input instead of LLM)")
    parser.add_argument("--ai-starts", action="store_true", help="AI plays X (starts)")
    parser.add_argument("--size", type=int, default=19, help="Board size")
    return parser.parse_args()

def check_health(base_url):
    try:
        with urllib.request.urlopen(f"{base_url}/health") as response:
            if response.status == 200:
                print(f"Connected to {base_url}")
                return True
    except Exception as e:
        print(f"Failed to connect to {base_url}: {e}")
        return False

def call_llm(prompt, model, api_key):
    """
    Calls OpenAI API. Returns the content of the response.
    """
    url = "https://api.openai.com/v1/chat/completions"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }
    data = {
        "model": model,
        "messages": [
            {"role": "system", "content": "You are a Gomoku (Five in a Row) expert. You play strictly by analyzing the board. You respond ONLY with the coordinates of your move in the format 'Row Col' (e.g., '10 10'). Rows and Cols are 0-indexed. Top-left is 0 0."},
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.2
    }
    
    req = urllib.request.Request(url, json.dumps(data).encode('utf-8'), headers)
    try:
        with urllib.request.urlopen(req) as response:
            res_body = json.loads(response.read())
            return res_body['choices'][0]['message']['content'].strip()
    except Exception as e:
        print(f"LLM Call Error: {e}")
        return None

def format_board(game_state):
    """
    Formats the board for the LLM.
    """
    size = game_state['board_size']
    rows = game_state['board_state']
    
    # Create column headers
    header = "   " + " ".join([f"{i:<2}" for i in range(size)])
    board_str = "Current Board:\n" + header + "\n"
    
    for i, row in enumerate(rows):
        # Row content comes as ". . . X O .", verify spacing
        # The API returns space-separated symbols.
        # We'll just prefix it with row index.
        board_str += f"{i:<2} {row}\n"
        
    board_str += f"\nLast move: {get_last_move_text(game_state)}"
    board_str += "\nYour move (Row Col):"
    return board_str

def get_last_move_text(game_state):
    moves = game_state.get("moves", [])
    if not moves:
        return "None"
    last = moves[-1]
    # Find which key is the player
    for k, v in last.items():
        if k not in ["time_ms", "score", "moves_evaluated", "opponent", "winner"]:
           return f"{k}: {v}"
    return "Unknown"

def send_state(base_url, game_state):
    url = f"{base_url}/gomoku/play"
    data = json.dumps(game_state).encode('utf-8')
    req = urllib.request.Request(url, data, {"Content-Type": "application/json"})
    try:
        with urllib.request.urlopen(req) as response:
            return json.loads(response.read())
    except urllib.error.HTTPError as e:
        print(f"HTTP Error {e.code}: {e.read().decode()}")
        return None
    except Exception as e:
        print(f"Request Error: {e}")
        return None

def parse_move(move_str, size):
    try:
        parts = move_str.replace(',', ' ').split()
        if len(parts) < 2:
            return None
        r, c = int(parts[0]), int(parts[1])
        if 0 <= r < size and 0 <= c < size:
            return r, c
    except:
        pass
    return None

def main():
    args = parse_args()
    
    if not check_health(args.url):
        sys.exit(1)
        
    api_key = os.environ.get("OPENAI_API_KEY")
    if not args.manual and not api_key:
        print("Error: OPENAI_API_KEY not set. Use --manual to play yourself.")
        sys.exit(1)

    # Initialize Game State
    # X is Player 1.
    # If --ai-starts, X=AI, O=Human
    # If not --ai-starts (default), X=Human, O=AI
    
    game_state = {
        "board_size": args.size,
        "X": {"player": "AI" if args.ai_starts else "human", "depth": 2},
        "O": {"player": "human" if args.ai_starts else "AI", "depth": 2},
        "board_state": [], # Will be ignored/overwritten/generated by server if empty? 
                           # Actually send_state expects full state logic.
                           # Initial state must be valid.
                           # If we don't send board_state, server might error? 
                           # json_api.c expects logic.
                           # Wait, we need to construct the initial empty board_state manually?
                           # NO, json_api_parse_game initializes a NEW game if board_state is missing?
                           # Checking json_api.c: it parses board_state if present. 
                           # If we send empty JSON with just config, does it work?
                           # Let's try sending just the config.
    }
    
    # We must construct a valid initial payload.
    # The server is stateless, so we must provide the state.
    # Initial empty state:
    empty_row = ". " * (args.size - 1) + "."
    game_state["board_state"] = [empty_row for _ in range(args.size)]
    game_state["moves"] = []

    # If AI starts, we send the initial state to server immediately to let it play X
    if args.ai_starts:
        print("AI is thinking (First move)...")
        new_state = send_state(args.url, game_state)
        if not new_state:
            sys.exit(1)
        game_state = new_state

    # Main Loop
    while True:
        # Check winner
        winner = game_state.get("winner", "none")
        if winner != "none":
            print(format_board(game_state))
            print(f"Game Over! Winner: {winner}")
            break

        # Human (or LLM) turn
        board_txt = format_board(game_state)
        print("\n" + board_txt)
        
        move = None
        while move is None:
            if args.manual:
                try:
                    move_str = input("Enter move (Row Col): ")
                except EOFError:
                    print("\nInput closed, exiting.")
                    return
            else:
                print("Asking LLM for move...")
                move_str = call_llm(board_txt, args.model, api_key)
                print(f"LLM suggested: {move_str}")
            
            move = parse_move(move_str, args.size)
            if not move:
                print("Invalid move format. Try '10 10'.")
                # Ensure we don't infinite loop if LLM keeps failing
                if not args.manual: 
                    print("LLM failed to output valid move. Aborting.")
                    sys.exit(1)

        # Apply move to local state
        r, c = move
        player_symbol = "O" if args.ai_starts else "X"
        player_key = f"{player_symbol} (human)"
        
        move_obj = {
            player_key: [r, c],
            "time_ms": 0.0 # Client measured time
        }
        
        # We append the move to the history. 
        # Note: We rely on the server to re-validate the whole history and play THE NEXT move.
        game_state["moves"].append(move_obj)
        
        # Send to server
        print("Sending move to server...")
        new_state = send_state(args.url, game_state)
        
        if not new_state:
            print("Server rejected move (illegal?)")
            # Pop the invalid move
            game_state["moves"].pop()
            continue
            
        game_state = new_state

if __name__ == "__main__":
    main()
