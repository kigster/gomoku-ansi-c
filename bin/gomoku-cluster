#!/usr/bin/env bash
# shellcheck disable=SC2126

set +e

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

function script.setup() {
  # Install bashmatic if not installed
  [[ -d ~/.bashmatic ]] || bash -c "$(curl -fsSL https://bashmatic.re1.re); bashmatic-install -q" >/dev/null 2>&1
  # shellcheck disable=SC1090
  source ~/.bashmatic/init >/dev/null 2>&1
  script.dependencies
}

function script.dependencies() {
  command -v direnv >/dev/null 2>&1 || { package.install direnv; }
  command -v direnv >/dev/null 2>&1 && direnv allow .
}


# We are replacing pkill using bashmatic's pid.matchin and pid.stop-and-kill functions.
function pkill() {
  shift # remove -f
  local pattern="$1"; shift
  local -a pids=("$(pids.matching "$pattern")")
  [[ ${#pids[@]} -eq 0 ]] && return 0
  local pid
  run.set-all continue-on-error
  for pid in "${pids[@]}"; do
    if [[ -n ${pid} ]] && pid.alive "$pid"; then
      pid.stop "$pid"
    fi
  done
}

# =============================================================================
# NGINX Functions
# =============================================================================

function nginx.start() {
  inf "Starting nginx..."
  run.set-all abort-on-error

  if [[ -z $(pids.matching nginx) ]]; then
    sudo /opt/homebrew/bin/nginx -g "daemon on;"
  else
    ui.closer.kind-of-ok:
    success "nginx is already running, $(pids.matching nginx | wc -l | tr -d ' ') processes."
    return 0
  fi

  sleep 1

  if [[ -z $(pids.matching nginx) ]]; then
    ui.closer.not-ok:
    error "nginx failed to start, please look at /var/log/nginx/error.log"
    [[ -f /var/log/nginx/error.log ]] && tail -n 20 /var/log/nginx/error.log
    return 1
  else
    ui.closer.ok:
    success "nginx started successfully."
  fi
}

function nginx.stop() {
  inf "Stopping nginx..."
  
  if [[ -n $(pids.matching nginx) ]]; then
    sudo /opt/homebrew/bin/nginx -s quit >/dev/null 2>&1 || true
    sleep 4
    
    # Force kill if still running
    if [[ -n $(pids.matching nginx) ]]; then
      ui.closer.not-ok:
      warning "nginx didn't stop gracefully, force killing..."
      sudo pkill -9 "nginx"
    else
      ui.closer.ok:
      success "nginx stopped successfully."
      return
    fi

    inf "Checking if nginx has stopped..."

    # Force kill if still running
    if [[ -z $(pids.matching nginx) ]]; then
      ui.closer.ok:
      success "nginx stopped successfully."
    else
      ui.closer.not-ok:
      error "nginx failed to stop."
    fi
  else
    ui.closer.kind-of-ok:
    success "nginx is not running."
  fi
}

function nginx.restart() {
  inf "Restarting nginx..."
  nginx.stop
  sleep 1
  nginx.start
  ui.closer.ok:
}

function nginx.status() {
  inf "nginx status..."
  
  if pgrep -f "nginx" >/dev/null; then
    ui.closer.ok:
    success "nginx is running (PID: $(pgrep -f nginx | tr '\n' ' '))"
    
    # Try to get nginx status if available
    if command -v curl >/dev/null 2>&1; then
      echo "Checking nginx status endpoint..."
      curl -s http://127.0.0.1/nginx_status 2>/dev/null || echo "No status endpoint configured"
    fi
  else
    ui.closer.kind-of-ok:
    warning "nginx is not running."
  fi
}

# =============================================================================
# HAPROXY Functions
# =============================================================================

function haproxy.start() {
  inf "Starting haproxy..."
  if [[ -z $(pids.matching haproxy) ]]; then
    /opt/homebrew/opt/haproxy/bin/haproxy -D -f /opt/homebrew/etc/haproxy.cfg;
    sleep 1
    if [[ -z $(pids.matching haproxy) ]]; then
      ui.closer.not-ok:
      error "haproxy failed to start, try starting it by hand."
      return 1
    else
      ui.closer.ok:
      success "haproxy started successfully."
    fi
  else
    ui.closer.kind-of-ok:
    info "haproxy is already running, skipping start."
  fi
}

function haproxy.stop() {
  inf "Stopping haproxy..."
  
  if [[ -n $(pids.matching haproxy) ]]; then
    pkill -9 "haproxy"
    ui.closer.ok:
    success "haproxy stopped successfully."
  else
    ui.closer.kind-of-ok:
    success "haproxy is not running."
  fi
}

function haproxy.restart() {
  inf "Restarting haproxy..."
  haproxy.stop
  sleep 1
  haproxy.start
  ui.closer.ok:
}

function haproxy.status() {
  inf "haproxy status..."
  
  if [[ -n $(pids.matching haproxy) ]]; then
    ui.closer.ok:
    success "haproxy is running (PID: $(pgrep -f haproxy | tr '\n' ' '))"
    
    # Get haproxy admin URL and show stats
    if [[ -f /opt/homebrew/etc/haproxy.cfg ]]; then
      local haproxy_admin_url
      haproxy_admin_url=$(grep -A 3 stats /opt/homebrew/etc/haproxy.cfg | grep bind | awk '{print $2}' | head -1)
      if [[ -n "$haproxy_admin_url" ]]; then
        echo "Admin interface: http://${haproxy_admin_url}/stats"
        if command -v curl >/dev/null 2>&1; then
          echo "Stats summary:"
          curl -s "http://${haproxy_admin_url}/stats;csv" 2>/dev/null | head -5 || echo "Could not fetch stats"
        fi
      fi
    fi
  else
    ui.closer.kind-of-ok:
    warning "haproxy is not running."
  fi
}

# =============================================================================
# ENVOY Functions
# =============================================================================

function envoy.start() {
  inf "Starting envoy..."
  
  if ! command -v envoy >/dev/null 2>&1; then
    ui.closer.kind-of-ok:
    success "envoy is not installed. Install with: brew install envoy"
    return 1
  fi
  
  local envoy_config="$PROJECT_DIR/iac/envoy/envoy.yaml"
  if [[ ! -f "$envoy_config" ]]; then
    ui.closer.not-ok:
    error "Envoy config not found: $envoy_config"
    return 1
  fi
  
  if [[ -z $(pids.matching envoy) ]]; then
    # Validate config first
    if ! envoy --mode validate -c "$envoy_config" >/dev/null 2>&1; then
      ui.closer.not-ok:
      error "Envoy configuration validation failed"
      envoy --mode validate -c "$envoy_config"
      return 1
    fi
    
    # Start envoy in background
    sudo nohup envoy -c "$envoy_config" >/dev/null 2>&1 &
    sleep 2
    
    if pgrep -f "envoy.*envoy.yaml" >/dev/null; then
      ui.closer.ok:
    else
      ui.closer.not-ok:
      error "envoy failed to start."
      return 1
    fi
  else
    ui.closer.ok:
    success "envoy is already running."
  fi
}

function envoy.stop() {
  inf "Stopping envoy..."
  
  if [[ -n $(pids.matching envoy) ]]; then
    pkill -f "envoy.*envoy.yaml"
    sleep 2
    
    if ! pgrep -f "envoy.*envoy.yaml" >/dev/null; then
      ui.closer.ok:
      success "envoy stopped successfully."
    else
      ui.closer.not-ok:
      error "Failed to stop envoy."
      return 1
    fi
  else
    ui.closer.kind-of-ok:
    success "envoy is not running."
  fi
}

function envoy.restart() {
  inf "Restarting envoy..."
  envoy.stop
  sleep 1
  envoy.start
  ui.closer.ok:
}

function envoy.status() {
  inf "envoy status..."
  
  if pgrep -f "envoy.*envoy.yaml" >/dev/null; then
    ui.closer.ok:
    success "envoy is running (PID: $(pgrep -f 'envoy.*envoy.yaml' | tr '\n' ' '))"
    
    # Check envoy admin interface
    if command -v curl >/dev/null 2>&1; then
      echo "Admin interface: http://127.0.0.1:9901"
      echo "Checking envoy readiness..."
      if curl -s http://127.0.0.1:9901/ready >/dev/null 2>&1; then
        echo "✓ Envoy admin interface is responding"
        echo "Cluster status:"
        curl -s http://127.0.0.1:9901/clusters | grep -E "^gomoku_cluster::" | head -5
      else
        warning "Envoy admin interface not responding"
      fi
    fi
  else
    warning "envoy is not running."
  fi
}

# =============================================================================
# GOMOKU Functions
# =============================================================================

function gomoku.start() {
  local workers="${1}"
  inf "Starting Gomoku Cluster..."

  pgrep -f "gomoku-httpd" >/dev/null && {
    info "Stopping existing gomoku-httpd instances..."
    "$SCRIPT_DIR/gomokud-ctl" stop
  }

  sleep 1
  if ! pgrep -f "gomoku-httpd" >/dev/null; then
    [[ -z "$workers" ]] || workers="-w $workers"
    "$SCRIPT_DIR/gomokud-ctl" start "${workers}"
    sleep 1
    if ! pgrep -f "gomoku-httpd" >/dev/null; then
      ui.closer.not-ok:
      error "gomoku-httpd failed to start."
      return 1
    else
      ui.closer.ok:
      success "gomoku-httpd started successfully."
    fi
  else
    ui.closer.not-ok:
    error "Gomoku Cluster did not shutdown correctly."
    return 1
  fi
}

function gomoku.stop() {
  inf "Stopping Gomoku Cluster..."
  
  if pgrep -f "gomoku-httpd" >/dev/null; then
    "$SCRIPT_DIR/gomokud-ctl" stop
    sleep 2
    
    if ! pgrep -f "gomoku-httpd" >/dev/null; then
      ui.closer.ok:
      success "gomoku-httpd stopped successfully."
    else
      ui.closer.not-ok:
      error "Failed to stop gomoku-httpd."
      return 1
    fi
  else
    ui.closer.kind-of-ok:
    success "gomoku-httpd is not running."
  fi
}

function gomoku.restart() {
  inf "Restarting Gomoku Cluster..."
  gomoku.stop
  sleep 1
  gomoku.start
  ui.closer.ok:
}

function gomoku.status() {
  inf "gomoku-httpd status..."
  
  if pgrep -f "gomoku-httpd" >/dev/null; then
    ui.closer.ok:
    local pids
    pids=$(pgrep -f "gomoku-httpd" | tr '\n' ' ')
    success "gomoku-httpd is running (PIDs: $pids)"
    
    echo "Checking individual instances:"
    # Check each expected port
    for port in {9500..9509}; do
      if command -v curl >/dev/null 2>&1; then
        if curl -s --max-time 2 "http://127.0.0.1:$port/ready" >/dev/null 2>&1; then
          echo "✓ Port $port: responding"
        else
          echo "✗ Port $port: not responding"
        fi
      else
        if nc -z 127.0.0.1 "$port" 2>/dev/null; then
          echo "✓ Port $port: listening"
        else
          echo "✗ Port $port: not listening"
        fi
      fi
    done
  else
    ui.closer.kind-of-ok:
    warning "gomoku-httpd is not running."
  fi
}

# =============================================================================
# Main Commands
# =============================================================================

function cmd_start() {
  local proxy="haproxy" # default to haproxy
  local components=()
  local workers=
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -w|--workers)
        workers="$2"
        shift 2
        [[ ${workers} =~ ^[0-9]+$ ]] || { error "Invalid workers: $workers"; return 1; }
        ;;
      -p|--proxy)
        proxy="$2"
        shift 2
        ;;
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        # ignore
        shift
        ;;
    esac
  done
  
  # Validate proxy option
  if [[ -n "$proxy" && "$proxy" != "haproxy" && "$proxy" != "envoy" ]]; then
    error "Invalid proxy: $proxy. Must be 'haproxy' or 'envoy'"
    return 1
  fi
  
  # If no components specified, start all with specified proxy
  if [[ ${#components[@]} -eq 0 ]]; then
    if [[ -z "$proxy" ]]; then
      error "Must specify --proxy when starting all components"
      show_usage
      return 1
    fi
    
    nginx.start
    if [[ "$proxy" == "haproxy" ]]; then
      haproxy.start
    else
      envoy.start
    fi
    gomoku.start "$workers"
    
    # Open admin interface
    if [[ "$proxy" == "haproxy" ]]; then
      local haproxy_admin_url
      haproxy_admin_url=$(grep -A 3 stats /opt/homebrew/etc/haproxy.cfg | grep bind | awk '{print $2}' | head -1)
      [[ -n "$haproxy_admin_url" ]] && open "http://${haproxy_admin_url}/stats"
    else
      open "http://127.0.0.1:9901"
    fi
  else
    # Start specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.start
          ;;
        haproxy)
          haproxy.start
          ;;
        envoy)
          envoy.start
          ;;
        gomoku-httpd|gomoku)
          gomoku.start
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
    done
  fi
}

function cmd_stop() {
  local components=()
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        error "Unknown option: $1"
        show_usage
        return 1
        ;;
    esac
  done
  
  # If no components specified, stop all
  if [[ ${#components[@]} -eq 0 ]]; then
    gomoku.stop
    haproxy.stop
    envoy.stop
    nginx.stop
  else
    # Stop specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.stop
          ;;
        haproxy)
          haproxy.stop
          ;;
        envoy)
          envoy.stop
          ;;
        gomoku-httpd|gomoku)
          gomoku.stop
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
    done
  fi
}

function cmd_restart() {
  local components=()
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        error "Unknown option: $1"
        show_usage
        return 1
        ;;
    esac
  done
  
  # If no components specified, restart all
  if [[ ${#components[@]} -eq 0 ]]; then
    gomoku.restart
    haproxy.restart
    envoy.restart
    nginx.restart
  else
    # Restart specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.restart
          ;;
        haproxy)
          haproxy.restart
          ;;
        envoy)
          envoy.restart
          ;;
        gomoku-httpd|gomoku)
          gomoku.restart
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
    done
  fi
}

function cmd_status() {
  local components=()
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        error "Unknown option: $1"
        show_usage
        return 1
        ;;
    esac
  done
  
  # If no components specified, show status for all
  if [[ ${#components[@]} -eq 0 ]]; then
    nginx.status
    echo
    haproxy.status
    echo
    envoy.status
    echo
    gomoku.status
  else
    # Show status for specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.status
          ;;
        haproxy)
          haproxy.status
          ;;
        envoy)
          envoy.status
          ;;
        gomoku-httpd|gomoku)
          gomoku.status
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
      echo
    done
  fi
}

function show_usage() {
  local binary="$(basename "$0")"

  echo -e "
${bldblu}USAGE:${clr} 
  ${bldylw}${binary} <command> [options]${clr}

${bldblu}Commands:${clr}
  ${bldylw}start     ${clr} # Start services
  ${bldylw}stop      ${clr} # Stop services  
  ${bldylw}restart   ${clr} # Restart services
  ${bldylw}status    ${clr} # Show service status

${bldblu}Start Options:${clr}
  ${bldylw}-p, --proxy <haproxy|envoy>    ${clr} # Specify proxy to use (required for start all)
  ${bldylw}-c, --component <name>         ${clr} # Component to start (can be used multiple times)

${bldblu}Stop/Restart/Status Options:${clr}
  ${bldylw}-c, --component <name>         ${clr} # Component to operate on (can be used multiple times)

${bldblu}Components:${clr}
  ${bldylw}nginx     ${clr} Nginx web server
  ${bldylw}haproxy   ${clr} HAProxy load balancer  
  ${bldylw}envoy     ${clr} Envoy proxy
  ${bldylw}gomoku    ${clr} Gomoku-httpd cluster (alias: gomoku-httpd)

${bldblu}Examples: Primary Modes:${clr}
  ${bldylw}${binary} start --proxy haproxy         ${clr}# Start all with HAProxy
  ${bldylw}${binary} start --proxy envoy           ${clr}# Start all with Envoy

${bldblu}Examples: Secondary Modes:${clr}
  ${bldylw}${binary} start -c nginx -c gomoku      ${clr}# Start only nginx and gomoku
  ${bldylw}${binary} stop -c haproxy               ${clr}# Stop only haproxy
  ${bldylw}${binary} restart -c envoy              ${clr}# Restart only envoy
  ${bldylw}${binary} status                        ${clr}# Show status of all components
  ${bldylw}${binary} status -c gomoku              ${clr}# Show status of gomoku only
  ${bldylw}${binary} htop                          ${clr}# Show top processes
"
}

# =============================================================================
# Main
# =============================================================================

function parse-args() {

  while [[ $# -gt 0 ]]; do

    # Main command dispatch
    case "${1}" in
      start)
        shift
        cmd_start "$@"
        return
        ;;
      stop)
        shift
        cmd_stop "$@"
        return
        ;;
      restart)
        shift
        cmd_restart "$@"
        return
        ;;
      status)
        shift
        cmd_status "$@"
        return
        ;;
      htop)
        shift
        command -v htop >/dev/null 2>&1 || { echo "htop is not installed. Please install it first." >&2; return 1; }
        htop -F 'nginx|haproxy|envoy|gomoku-httpd|gomoku`' "$@"
        exit 0
        ;;
      ""|--help|-h|help)
        show_usage "$@"
        ;;
      *)
        error "Unknown command: $1"
        show_usage "$@"
        return 1
        ;;
    esac
  done

  return $?
}

main() {
  parse-args "$@"
}

declare -a ARGV=("$@")
export ARGV

script.setup

function warning() {
  arrow.blk-on-ylw "$@"
}

main "${ARGV[@]}"
