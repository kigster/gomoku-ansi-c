#!/usr/bin/env bash
# shellcheck disable=SC2126

set +e

# Global variables
export SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
export OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
export DEFAULT_PROXY="envoy"

export REGEX='nginx|haproxy|envoy|gomoku-httpd|gomoku|vite'

declare -a UTILS
UTILS=(btop htop ctop btm)
export UTILS

declare -a PACKAGES
PACKAGES=(btop htop ctop bottom)
export PACKAGES

function filter.flag-for() {
  local program="$1"
  local regex="$2"
  case "$program" in
    btop)
      echo -n "--filter gomoku"
      return
      ;;
    htop)
      echo -n "-F '$regex'"
      return
      ;;
    btm)
      echo -n ""
      return
      ;;
    ctop)
      echo -n "-f '$regex'"
      return
      ;;
  esac
  return 0
}

if [[ $OS == darwin ]]; then
  BREW_HOME=$(brew --prefix)
fi

declare -a LOG_FILES
LOG_FILES=(
  "/var/log/nginx/access.log" 
  "/var/log/nginx/error.log" 
  "/var/log/envoy.log" 
  "/var/log/haproxy.log" 
  "/var/log/gomoku-httpd.log"
  "/var/log/envoy.log"
  "/var/log/gomoku-frontend.log"
)
export LOG_FILES

function setup.bashmatic() {
  # Install bashmatic if not installed
  [[ -d ~/.bashmatic ]] || bash -c "$(curl -fsSL https://bashmatic.re1.re); bashmatic-install -q" >/dev/null 2>&1
  # shellcheck disable=SC1090
  source ~/.bashmatic/init >/dev/null 2>&1
}

function setup.log-files-are-ok() {
  for file in "${LOG_FILES[@]}"; do
    [[ -w "$file" ]] || {
      error "Log file [${file}] either does not exist or is not writable." 
      sleep 1
      hint "HINT: Run the following command first: " "$(basename $0) setup"
      return 1
    }
  done
}

function setup.sudo() {
  h3 "Setting up sudo and the ownership of the log files..."
  sudo -n date >/dev/null 2>&1 || {
    h.yellow "sudo is not authenticated, please enter your password to authenticate:"
    sudo -v
    local code=$?
    [[ $code -ne 0 ]] && {
      error "sudo authentication failed."
      return 1
    }
  }

  run "sudo chmod 777 /var/log"

  for file in "${LOG_FILES[@]}"; do
    run "sudo mkdir -p $(dirname "$file")"
    run "sudo touch $file"
    run "sudo chown $USER $file"
    run "sudo chmod 666 $file"
  done

  run "sudo chown $USER /var/log/nginx"
  success "All log files exist and are writeable."
}

function setup.direnv() {
  command -v direnv >/dev/null 2>&1 || { package.install direnv; }
  command -v direnv >/dev/null 2>&1 && direnv allow .
}

function setup.utils() {
  for package in "${PACKAGES[@]}"; do
    package.is-installed "$package" || { package.install "$package" || true; }
  done
}

function cmd_setup() {
  setup.bashmatic
  setup.sudo
  setup.direnv
  setup.utils 
}

# We are replacing pkill using bashmatic's pid.matchin and pid.stop-and-kill functions.
function pkill() {
  shift # remove -f
  local pattern="$1"; shift
  local -a pids=("$(pids.matching "$pattern")")
  [[ ${#pids[@]} -eq 0 ]] && return 0
  local pid
  run.set-all continue-on-error
  for pid in "${pids[@]}"; do
    if [[ -n ${pid} ]] && pid.alive "$pid"; then
      pid.stop "$pid"
    fi
  done
}

# =============================================================================
# NGINX Functions
# =============================================================================

function nginx.start() {
  inf "Starting nginx..."
  run.set-all abort-on-error

  if [[ -z $(pids.matching [n]ginx) ]]; then
    sudo ${BREW_HOME}/bin/nginx -c ${PROJECT_DIR}/iac/config/nginx.conf -g "daemon on;"
  else
    ui.closer.kind-of-ok:
    success "nginx is already running, $(pids.matching nginx | wc -l | tr -d ' ') processes."
    return 0
  fi

  sleep 1

  if [[ -z $(pids.matching [n]ginx) ]]; then
    ui.closer.not-ok:
    error "nginx failed to start, please look at /var/log/nginx/error.log"
    [[ -f /var/log/nginx/error.log ]] && tail -n 20 /var/log/nginx/error.log
    return 1
  else
    ui.closer.ok:
    success "nginx started successfully."
  fi
}

function nginx.stop() {
  inf "Stopping nginx..."
  
  if [[ -n $(pids.matching [n]ginx) ]]; then
    sudo ${BREW_HOME}/bin/nginx -s quit >/dev/null 2>&1 || true
    sleep 4
    
    # Force kill if still running
    if [[ -n $(pids.matching [n]ginx) ]]; then
      ui.closer.not-ok:
      warning "nginx didn't stop gracefully, force killing..."
      pkill -9 "nginx"
    else
      ui.closer.ok:
      success "nginx stopped successfully."
      return
    fi

    inf "Checking if nginx has stopped..."

    # Force kill if still running
    if [[ -z $(pids.matching [n]ginx) ]]; then
      ui.closer.ok:
      success "nginx stopped successfully."
    else
      ui.closer.not-ok:
      error "nginx failed to stop."
    fi
  else
    ui.closer.kind-of-ok:
    success "nginx is not running."
  fi
}

function nginx.restart() {
  inf "Restarting nginx..."
  nginx.stop
  sleep 1
  nginx.start
  ui.closer.ok:
}

function nginx.status() {
  inf "nginx status..."
  
  if pgrep -f "nginx" >/dev/null; then
    ui.closer.ok:
    success "nginx is running (PID: $(pgrep -f nginx | tr '\n' ' '))"
    
    # Try to get nginx status if available
    if command -v curl >/dev/null 2>&1; then
      echo "Checking nginx status endpoint..."
      curl -s http://127.0.0.1/nginx_status 2>/dev/null || echo "No status endpoint configured"
    fi
  else
    ui.closer.kind-of-ok:
    warning "nginx is not running."
  fi
}

# =============================================================================
# HAPROXY Functions
# =============================================================================

function haproxy.start() {
  inf "Starting haproxy..."
  if [[ -z $(pids.matching [h]aproxy) ]]; then
    ${BREW_HOME}/opt/haproxy/bin/haproxy -D -f ${PROJECT_DIR}/iac/config/haproxy.cfg;
    sleep 1
    if [[ -z $(pids.matching [h]aproxy) ]]; then
      ui.closer.not-ok:
      error "haproxy failed to start, try starting it by hand."
      return 1
    else
      ui.closer.ok:
      success "haproxy started successfully."
    fi
  else
    ui.closer.kind-of-ok:
    info "haproxy is already running, skipping start."
  fi
}

function haproxy.stop() {
  inf "Stopping haproxy..."
  
  if [[ -n $(pids.matching [h]aproxy) ]]; then
    pkill -9 "haproxy"
    ui.closer.ok:
    success "haproxy stopped successfully."
  else
    ui.closer.kind-of-ok:
    success "haproxy is not running."
  fi
}

function haproxy.restart() {
  inf "Restarting haproxy..."
  haproxy.stop
  sleep 1
  haproxy.start
  ui.closer.ok:
}

function haproxy.status() {
  inf "haproxy status..."
  
  if [[ -n $(pids.matching [h]aproxy) ]]; then
    ui.closer.ok:
    success "haproxy is running (PID: $(pgrep -f haproxy | tr '\n' ' '))"
    
    # Get haproxy admin URL and show stats
    if [[ -f ${BREW_HOME}/etc/haproxy.cfg ]]; then
      local haproxy_admin_url
      haproxy_admin_url=$(grep -A 3 stats ${BREW_HOME}/etc/haproxy.cfg | grep bind | awk '{print $2}' | head -1)
      if [[ -n "$haproxy_admin_url" ]]; then
        echo "Admin interface: http://${haproxy_admin_url}/stats"
        if command -v curl >/dev/null 2>&1; then
          echo "Stats summary:"
          curl -s "http://${haproxy_admin_url}/stats;csv" 2>/dev/null | head -5 || echo "Could not fetch stats"
        fi
      fi
    fi
  else
    ui.closer.kind-of-ok:
    warning "haproxy is not running."
  fi
}

# =============================================================================
# ENVOY Functions
# =============================================================================

function envoy.start() {
  hint "Starting envoy..."

  inf "Checking if envoy is installed..."
  if ! command -v envoy >/dev/null 2>&1; then
    ui.closer.not-ok:

    inf "Installing envoy..."
    package.install envoy
    
    command -v envoy >/dev/null 2>&1 || {
      ui.closer.not-ok:
      error "envoy is not installed. Please install it manually."
      return 1
    }

    ui.closer.ok:
    success "envoy has been installed, awesome!"
  else
    ui.closer.ok:
  fi
  
  local envoy_config="$PROJECT_DIR/iac/envoy/envoy.yaml"
  if [[ ! -f "$envoy_config" ]]; then
    error "Envoy config not found: $envoy_config"
    return 1
  fi
  
  # Validate config first
  inf "Validating envoy configuration..."
  if ! envoy --mode validate -c "$envoy_config" >/dev/null 2>&1; then
    ui.closer.not-ok:
    error "Envoy configuration validation failed"
    envoy --mode validate -c "$envoy_config"
    return 1
  else
    ui.closer.ok:
  fi

  inf "Checking if envoy is already running..."
  if [[ -z "$(pids.matching [e]nvoy)" ]]; then
    ui.closer.not-ok:

    inf "Envoy isn't running, so starting envoy in background..."
    # Start envoy in background
    nohup envoy -c "$envoy_config" --log-path /var/log/envoy.log &
    sleep 1

    if [[ -n $(pids.matching [e]nvoy) ]]; then
      ui.closer.ok:
      success "envoy started successfully."
    else
      ui.closer.not-ok:
      error "envoy failed to start."
      return 1
    fi
  else
    ui.closer.ok:
    success "envoy is already running."
  fi
}

function envoy.stop() {
  inf "Stopping envoy..."
  
  if [[ -n "$(pids.matching [e]nvoy)" ]]; then
    pkill -f "[e]nvoy"
    sleep 2
    
    if ! pgrep -f "[e]nvoy" >/dev/null; then
      ui.closer.ok:
      success "envoy stopped successfully."
    else
      ui.closer.not-ok:
      error "Failed to stop envoy."
      return 1
    fi
  else
    ui.closer.kind-of-ok:
    success "envoy is not running."
  fi
}

function envoy.restart() {
  inf "Restarting envoy..."
  envoy.stop
  sleep 1
  envoy.start
  ui.closer.ok:
}

function envoy.status() {
  inf "envoy status..."
  
  if [[ -n $(pids.matching [e]nvoy) ]]; then
    ui.closer.ok:
    success "envoy is running (PID: $(pgrep -f [e]nvoy | tr '\n' ' '))"
    
    # Check envoy admin interface
    if command -v curl >/dev/null 2>&1; then
      echo "Admin interface: http://127.0.0.1:9901"
      echo "Checking envoy readiness..."
      if curl -s http://127.0.0.1:9901/ready >/dev/null 2>&1; then
        echo "✓ Envoy admin interface is responding"
        echo "Cluster status:"
        curl -s http://127.0.0.1:9901/clusters | grep -E "^gomoku_cluster::" | head -5
      else
        warning "Envoy admin interface not responding"
      fi
    fi
  else
    warning "envoy is not running."
  fi
}

# =============================================================================
# FRONTEND Functions
# =============================================================================

function frontend.start() {
  inf "Starting frontend dev server..."

  if [[ -n "$(pids.matching '[v]ite')" ]]; then
    ui.closer.kind-of-ok:
    success "frontend dev server is already running."
    return 0
  fi

  local frontend_dir="$PROJECT_DIR/frontend"
  if [[ ! -f "$frontend_dir/package.json" ]]; then
    ui.closer.not-ok:
    error "frontend/package.json not found. Is the frontend set up?"
    return 1
  fi

  # Install deps if needed
  if [[ ! -d "$frontend_dir/node_modules" ]]; then
    inf "Installing frontend dependencies..."
    (cd "$frontend_dir" && npm install) >/dev/null 2>&1
    ui.closer.ok:
  fi

  # Start vite dev server in background
  nohup bash -c "cd '$frontend_dir' && npm run dev" >/var/log/gomoku-frontend.log 2>&1 &
  sleep 2

  if [[ -n "$(pids.matching '[v]ite')" ]]; then
    ui.closer.ok:
    success "frontend dev server started (http://localhost:5173)."
    open "http://localhost:5173"
  else
    ui.closer.not-ok:
    error "frontend dev server failed to start. Check /var/log/gomoku-frontend.log"
    return 1
  fi
}  

function frontend.stop() {
  inf "Stopping frontend dev server..."

  if [[ -n "$(pids.matching '[v]ite')" ]]; then
    pkill -f "[v]ite"
    sleep 1

    if [[ -z "$(pids.matching '[v]ite')" ]]; then
      ui.closer.ok:
      success "frontend dev server stopped successfully."
    else
      ui.closer.not-ok:
      error "Failed to stop frontend dev server."
      return 1
    fi
  else
    ui.closer.kind-of-ok:
    success "frontend dev server is not running."
  fi
}

function frontend.restart() {
  inf "Restarting frontend dev server..."
  frontend.stop
  sleep 1
  frontend.start
  ui.closer.ok:
}

function frontend.status() {
  inf "frontend dev server status..."

  if [[ -n "$(pids.matching '[v]ite')" ]]; then
    ui.closer.ok:
    success "frontend dev server is running (PID: $(pids.matching '[v]ite' | tr '\n' ' '))"
    echo "URL: http://localhost:5173"
  else
    ui.closer.kind-of-ok:
    warning "frontend dev server is not running."
  fi
}

# =============================================================================
# GOMOKU Functions
# =============================================================================

function gomoku.start() {
  local workers="${1}"
  inf "Starting Gomoku Cluster..."

  [[ -n $(pids.matching [g]omoku-httpd) ]] && {
    info "Stopping existing gomoku-httpd instances..."
    "$SCRIPT_DIR/gomoku-httpd-ctl" stop
  }

  sleep 1
  if [[ -z $(pids.matching [g]omoku-httpd) ]]; then
    [[ -z "$workers" ]] || workers="-w $workers"
    "$SCRIPT_DIR/gomoku-httpd-ctl" start "${workers}"
    sleep 1
    if [[ -n $(pids.matching [g]omoku-httpd) ]]; then
      ui.closer.not-ok:
      error "gomoku-httpd failed to start."
      return 1
    else
      ui.closer.ok:
      success "gomoku-httpd started successfully."
    fi
  else
    ui.closer.not-ok:
    error "Gomoku Cluster did not shutdown correctly."
    return 1
  fi
}

function gomoku.stop() {
  inf "Stopping Gomoku Cluster..."
  
  if [[ -n $(pids.matching [g]omoku-httpd) ]]; then
    "$SCRIPT_DIR/gomoku-httpd-ctl" stop
    sleep 2
    
    if [[ -z $(pids.matching [g]omoku-httpd) ]]; then
      ui.closer.ok:
      success "gomoku-httpd stopped successfully."
    else
      ui.closer.not-ok:
      error "Failed to stop gomoku-httpd."
      return 1
    fi
  else
    ui.closer.kind-of-ok:
    success "gomoku-httpd is not running."
  fi
}

function gomoku.restart() {
  inf "Restarting Gomoku Cluster..."
  gomoku.stop
  sleep 1
  gomoku.start
  ui.closer.ok:
}

function gomoku.status() {
  inf "gomoku-httpd status..."
  
  if [[ -n $(pids.matching [g]omoku-httpd) ]]; then
    ui.closer.ok:
    local -a pids=( $(pids.matching [g]omoku-httpd) )
    success "gomoku-httpd is running (PIDs: ${pids[*]})"
    
    echo "Checking individual instances:"
    # Check each expected port
    for port in {9500..9509}; do
      if command -v curl >/dev/null 2>&1; then
        if curl -s --max-time 2 "http://127.0.0.1:$port/ready" >/dev/null 2>&1; then
          echo "✓ Port $port: responding"
        else
          echo "✗ Port $port: not responding"
        fi
      else
        if nc -z 127.0.0.1 "$port" 2>/dev/null; then
          echo "✓ Port $port: listening"
        else
          echo "✗ Port $port: not listening"
        fi
      fi
    done
  else
    ui.closer.kind-of-ok:
    warning "gomoku-httpd is not running."
  fi
}

# =============================================================================
# Main Commands
# =============================================================================

function cmd_start() {
  local proxy=${DEFAULT_PROXY}
  local components=()
  local workers=

  setup.sudo

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -w|--workers)
        workers="$2"
        shift 2
        [[ ${workers} =~ ^[0-9]+$ ]] || { error "Invalid workers: $workers"; return 1; }
        ;;
      -p|--proxy)
        proxy="$2"
        shift 2
        ;;
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        # ignore
        shift
        ;;
    esac
  done
  
  # Validate proxy option
  if [[ -n "$proxy" && "$proxy" != "haproxy" && "$proxy" != "envoy" ]]; then
    error "Invalid proxy: $proxy. Must be 'haproxy' or 'envoy'"
    return 1
  fi
  
  # If no components specified, start all with specified proxy
  if [[ ${#components[@]} -eq 0 ]]; then
    if [[ -z "$proxy" ]]; then
      error "Must specify --proxy when starting all components"
      show_usage
      return 1
    fi
    
    nginx.start
    if [[ "$proxy" == "haproxy" ]]; then
      haproxy.start
    else
      envoy.start
    fi
    gomoku.start "$workers"
    frontend.start

    # Open admin interface
    if [[ "$proxy" == "haproxy" ]]; then
      local haproxy_admin_url
      haproxy_admin_url=$(grep -A 3 stats ${BREW_HOME}/etc/haproxy.cfg | grep bind | awk '{print $2}' | head -1)
      [[ -n "$haproxy_admin_url" ]] && open "http://${haproxy_admin_url}/stats"
    else
      open "http://127.0.0.1:9901"
    fi
  else
    # Start specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.start
          ;;
        haproxy)
          haproxy.start
          ;;
        envoy)
          envoy.start
          ;;
        gomoku-httpd|gomoku)
          gomoku.start
          ;;
        frontend)
          frontend.start
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
    done
  fi
  success "Everything booted as you requested." 
  hint "To monitor run the following command:" "bin/gctl htop"

  sleep 1
  h1  "Showing you the process table, which you can always see with the command:" "bin/gctl ps"
  sleep 1
}

function cmd_ps() {
  export GREP_COLOR='1;33'
  local output=$(mktemp)

  /bin/ps -e -r -o pid,ppid,cpu,rss,command | \
    /usr/bin/grep -E -v 'gctl|htop|grep' | \
    /usr/bin/grep --color=always -E '[g]omoku|[h]aproxy|[e]nvoy|[n]ginx|CPU' > "$output"

  if [[ -s "$output" ]]; then
    arrow.blk-on-ylw "Below are the processes that belong to the Gomoku Cluster booted locally, sorted by CPU usage:"
    echo
    cat "$output"
    echo; hr   
  else
    error "No processes found that belong to the Gomoku Cluster."
    return 1
  fi
}

function cmd_stop() {
  local components=()
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        error "Unknown option: $1"
        show_usage
        return 1
        ;;
    esac
  done
  
  # If no components specified, stop all
  if [[ ${#components[@]} -eq 0 ]]; then
    frontend.stop
    gomoku.stop
    haproxy.stop
    envoy.stop
    nginx.stop
  else
    # Stop specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.stop
          ;;
        haproxy)
          haproxy.stop
          ;;
        envoy)
          envoy.stop
          ;;
        gomoku-httpd|gomoku)
          gomoku.stop
          ;;
        frontend)
          frontend.stop
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
    done
  fi
}

function cmd_restart() {
  local components=()
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        error "Unknown option: $1"
        show_usage
        return 1
        ;;
    esac
  done
  
  # If no components specified, restart all
  if [[ ${#components[@]} -eq 0 ]]; then
    frontend.restart
    gomoku.restart
    haproxy.restart
    envoy.restart
    nginx.restart
  else
    # Restart specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.restart
          ;;
        haproxy)
          haproxy.restart
          ;;
        envoy)
          envoy.restart
          ;;
        gomoku-httpd|gomoku)
          gomoku.restart
          ;;
        frontend)
          frontend.restart
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
    done
  fi
}

function cmd_status() {
  local components=()
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -c|--component)
        components+=("$2")
        shift 2
        ;;
      *)
        error "Unknown option: $1"
        show_usage
        return 1
        ;;
    esac
  done
  
  # If no components specified, show status for all
  if [[ ${#components[@]} -eq 0 ]]; then
    nginx.status
    echo
    haproxy.status
    echo
    envoy.status
    echo
    gomoku.status
    echo
    frontend.status
  else
    # Show status for specified components
    for component in "${components[@]}"; do
      case "$component" in
        nginx)
          nginx.status
          ;;
        haproxy)
          haproxy.status
          ;;
        envoy)
          envoy.status
          ;;
        gomoku-httpd|gomoku)
          gomoku.status
          ;;
        frontend)
          frontend.status
          ;;
        *)
          error "Invalid component: $component"
          return 1
          ;;
      esac
      echo
    done
  fi
}

function cmd_observe() {
  local tool="$1"
  local regex="$2"
  

  if [[ -n "$1" ]] && array.includes "$1" "${UTILS[@]}"; then
    tool="$1"
  else  
    error "Unknown utility: $1"
    info "Available utilities: $(array.join ', ' "${UTILS[@]}")"
    return 1
  fi  

  "$tool" $(filter.flag-for "$tool" "$regex")
  return
}

function show_usage() {
  # shellcheck disable=SC2155
  local binary="$(basename "$0")"
  # shellcheck disable=SC2154
  local comment_color="${txtpur}${italic}"
  echo -e "
${bldblu}USAGE:${clr} 
  ${bldylw}${binary} <command> [options]${clr}

${bldblu}DESCRIPTION:${clr} 
  Controller script for the Gomoku Cluster in the development mode. This script can be used
  to start/stop/restart and obtain status from the entire interconnected cluster on a single
  machine.

${bldblu}COMMANDS:${clr} 

  ${comment_color}# When starting using ${bldylw}gctl start${comment_color} ou can either use haproxy or envoy as the 
  ${comment_color}# reverse proxy. Provide ${bldylw}-p <haproxy|envoy>${comment_color} to specify the proxy to use 
  # when starting all components.

  ${comment_color}# Boot the entire cluster with the specified proxy. Optionally specify a component to start.
  ${bldylw}bin/gctl start [ -p <haproxy|envoy> ] [ -c | -components <name> ] ${clr} 

  ${bldblu}# components:${clr}
     * ${bldylw}nginx${clr}    listening on ports 80 and 443
     * ${bldylw}haproxy${clr}  load balancer listening on port 10000 as the front-end, and 8404 as the admin interface
     * ${bldylw}envoy${clr}    Envoy proxy listening on port 10000 as the front-end, and 9901 as the admin interface
     * ${bldylw}gomoku${clr}   Gomoku-httpd cluster listening on ports 9500-9509
     * ${bldylw}frontend${clr} reactJS/Vite dev server listening on port 5173

${bldblu}Commands:${clr}
  ${bldylw}start     ${clr} # Start services
  ${bldylw}stop      ${clr} # Stop services  
  ${bldylw}restart   ${clr} # Restart services
  ${bldylw}status    ${clr} # Show service status
  ${bldylw}observe   ${clr} # Observe service with the specified tool (htop, btop, ctop, btm)
  ${bldylw}ps        ${clr} # Show process status

${bldblu}Start Options:${clr}
  ${bldylw}-p, --proxy <haproxy|envoy>    ${clr} # Specify proxy to use (required for start all)
  ${bldylw}-c, --component <name>         ${clr} # Component to start (can be used multiple times)

${bldblu}Stop/Restart/Status Options:${clr}
  ${bldylw}-c, --component <name>         ${clr} # Component to operate on (can be used multiple times)

${bldblu}Components:${clr}
  ${bldylw}nginx     ${clr} Nginx web server
  ${bldylw}haproxy   ${clr} HAProxy load balancer
  ${bldylw}envoy     ${clr} Envoy proxy (default)
  ${bldylw}gomoku    ${clr} Gomoku-httpd cluster (alias: gomoku-httpd)
  ${bldylw}frontend  ${clr} Vite React frontend dev server (http://localhost:5173)

${bldblu}Examples: Primary Modes:${clr}
  ${bldylw}${binary} start --proxy haproxy         ${clr}# Start all with HAProxy (incl. frontend)
  ${bldylw}${binary} start --proxy envoy           ${clr}# Start all with Envoy (incl. frontend)

${bldblu}Examples: Secondary Modes:${clr}
  ${bldylw}${binary} start -c nginx -c gomoku      ${clr}# Start only nginx and gomoku
  ${bldylw}${binary} start -c frontend             ${clr}# Start only the frontend dev server

  ${bldylw}${binary} stop -c haproxy               ${clr}# Stop only haproxy
  ${bldylw}${binary} stop -c frontend              ${clr}# Stop only the frontend dev server
  
  ${bldylw}${binary} restart -c envoy              ${clr}# Restart only envoy
  
  ${bldylw}${binary} status                        ${clr}# Show status of all components
  ${bldylw}${binary} status -c gomoku              ${clr}# Show status of gomoku only
  ${bldylw}${binary} status -c frontend            ${clr}# Show frontend dev server status
  ${bldylw}${binary} ps                            ${clr}# Show process status
  ${bldylw}${binary} observe htop                  ${clr}# Observe processes with htop
  ${bldylw}${binary} observe btop                  ${clr}# Observe processes with btop
  ${bldylw}${binary} observe btm                   ${clr}# Observe processes with btm
"
}

# =============================================================================
# Main
# =============================================================================

function parse-args() {

  while [[ $# -gt 0 ]]; do

    # Main command dispatch
    case "${1}" in
      start)
        shift
        cmd_start "$@"
        return
        ;;
      stop)
        shift
        cmd_stop "$@"
        return
        ;;
      restart)
        shift
        cmd_restart "$@"
        return
        ;;
      status)
        shift
        cmd_status "$@"
        return
        ;;
      setup)
        shift
        cmd_setup "$@"
        return
        ;;
      observe)
        shift
        cmd_observe "${1:-btop}" "${REGEX}"
        return
        ;;
      ps)
        shift
        cmd_ps "$@"
        return
        ;;
      ""|--help|-h|help)
        show_usage "$@"
        exit 0
        ;;
      *)
        error "Unknown command: $1"
        show_usage "$@"
        return 1
        ;;
    esac
  done

  return $?
}

main() {
  [[ -z "$*" ]] && {
    show_usage
    exit 0
  }
  parse-args "$@"
}

declare -a ARGV=("$@")
export ARGV

setup.bashmatic

function warning() {
  arrow.blk-on-ylw "$@"
}

function hint() {
  panel-info-blue-black "$@"
}

setup.direnv

[[ "$*" =~ setup ]] || setup.log-files-are-ok || exit 1

main "${ARGV[@]}"
